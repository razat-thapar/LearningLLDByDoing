# Design patterns cheat sheet

| Pattern Name | Type | One liner motivation | Steps | Example use case |
| --- | --- | --- | --- | --- |
| Singleton | Creational | Ensure a class has only one instance, and provide a global point of access to it. | 1. Make the constructor private to prevent instantiation. 2. Create a static creation method that acts as a constructor. | 1. Database connection. 2. Logger. |
| Builder | Creational | Allow construction of immutable objects. Especially useful for classes with many fields and complex validations | 1. Create a static inner class that contains all the fields of the outer class. 2. Add chained methods to the inner class to set the fields. 3. Add a build method that returns the outer class. | No particular example. You can use it whenever you have a class with many fields and would like to avoid a constructor with many parameters. |
| Prototype | Creational | Create many objects when the creation process is expensive. | 1. Add an interface with a clone method. 2. Implement the interface in the classes that you want to clone. 3. Create the prototype object and store it in a registry. 4. When you need a new object, clone the prototype. | 1. Objects in a game. 2. Objects that require API calls to be created such as test data. |
| Simple Factory | Creational | Create objects without using subclasses. | 1. Add a common interface for all products 2. Implement the interface in all products. 3. Create a factory class with a static method that returns the interface. | 1. Button factory 2. Database connection factory |
| Factory Method | Creational | Create objects without using subclasses. | 1. Add a common interface for all products 2. Implement the interface in all products. 3. Add a factory interface 4. Implement the factory interface in all factories.| 1. Button factory 2. Database connection factory |
| Abstract Factory | Creational | Create families of related objects without specifying their concrete classes. | 1. Add common interfaces for each type of products 2. Implement the interfaces in all products. 3. Add a factory interface representing the family 4. Implement the different versions of the family. | 1. GUI factory 2. Database factory |
| Adapter | Structural | Convert the interface of a class into another interface clients expect. | 1. Add an interface for the adapter that will be used to convert the incompatible interfaces. 2. Implement the interface in the adapter class. 3. Transform the request to the format that the original class expects. | 1. API integration 2. Database connection |
| Flyweight | Structural | Reuse intrinsic properties of objects to save memory. | 1. Create a class for the intrinsic state 2. Create a class for the extrinsic state 3. Create a factory class that returns the intrinsic state. | 1. Text editor 2. Game development |
| Decorator | Structural | Add functionality to an object without changing its structure. | 1. Create a common product interface 2. Create the concrete products 3. Create a base decorator class that extends the product interface 4. Create concrete decorators that extend the base decorator class. | 1. Adding functionality to databases 2. Frontend development |
| Facade | Structural | Provide a unified interface to a set of interfaces in a subsystem. | 1. Create a facade class that provides a unified interface to the subsystem. 2. Move the implementation of the subsystem to the facade class. 3. Call the facade class from the client. | Complex flows such as e-commerce checkout, payment, etc. |
| Observer | Behavioral | Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. | 1. Create a subject interface with methods to add, remove and notify observers. 2. Create a concrete subject class that implements the subject interface. 3. Create an observer interface with a method to update the state. 4. Create concrete observer classes that implement the observer interface. 5. Add the observers to the subject. | 1. Event listeners 2. UI updates |
| Strategy | Behavioral | Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it. | 1. Create a strategy interface with a method to execute the algorithm. 2. Create concrete strategy classes that implement the strategy interface. 3. Create a context class that uses the strategy interface. 4. Add a field for the strategy object | Applications that require multiple algorithms such as amount, tax, discount calculations. |